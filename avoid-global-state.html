
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  简洁代码之道（2）：避免全局可变状态 - Sharehub
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="To be a professional software engineer.">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="Sharehub" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">Sharehub</a></h1>
  
    <h2>To be a professional software engineer.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:blog.xiaohansong.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_self" href="about.html">About</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div>
	<article class="hentry" role="article">
	<header>
			  	<h1 class="entry-title">简洁代码之道（2）：避免全局可变状态</h1>
				<p class="meta"><time datetime="2015-11-30T16:14:23+08:00" pubdate data-updated="true">2015/11/30</time></p>
			 </header>
		  	<div class="entry-content">
			  	<h2 id="toc_0">前言</h2>

<p>本文是我看了 <a href="https://www.youtube.com/playlist?list=PL693EFD059797C21E">谷歌简洁代码演讲系列</a> 中的 <a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E">全局状态与单例模式</a> 之后的总结。本文的主题是：避免全局可变状态。下面我们将围绕几个问题开展讨论：</p>

<ul>
<li>什么是全局状态</li>
<li>如何设计好的单例模式</li>
<li>如何设计好的 API</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">全局状态</h2>

<h3 id="toc_2">什么是全局状态</h3>

<blockquote>
<p>Talk is cheap, show me the code. -- Linus</p>
</blockquote>

<p>我们来用一个例子说明什么是全局状态。</p>

<pre><code class="language-text">class X {
    X() {...}

    public int doSomething() {...}
}

int a = new X().doSomething()
int b = new X().doSomething()
</code></pre>

<p>现在问题来了，<code>a</code> 等于 <code>b</code> 吗？事实上有两种可能的情况。</p>

<p>第一种情况：<code>X</code> 类不受全局状态的影响，此时 <code>a == b</code><br/>
<img src="media/15473672636904/15473727637949.png" alt=""/></p>

<p>当 <code>X</code> 被实例化时，它可能会同时创建多个其它对象，当它执行 <code>doSomething()</code> 的时候，得到的结果是一样。说明它是无状态的，每次执行都像 <code>1+1=2</code> 一样有一个确定的值。</p>

<p>第二种情况：<code>X</code> 类受到全局状态的影响，此时 <code>a != b</code><br/>
<img src="media/15473672636904/15473727757698.png" alt=""/></p>

<p>如果 <code>X</code> 在执行 <code>doSomething()</code> 的时候，其中的 <code>Z</code> 变量受到全局状态 <code>GS</code> 的影响，此时 <code>a==b</code> 可能就不成立了。因为程序的执行依赖全局状态，同样的方法可能会得到不同的结果。</p>

<h3 id="toc_3">全局状态的缺点</h3>

<p>全局状态相当常见，因为写起来方便。“啊，有一个新的功能要加入，我们加一个全局变量，再加一个条件语句跳转到新的方法就行了。”然而，这种方便却让程序变得难以维护和测试。所以，有一定经验的程序员都会认为全局状态令人讨厌，会避免使用它。</p>

<p>下面我们来列举全局状态的罪状：</p>

<ul>
<li>多次执行同一方法会产生不同的结果
<ul>
<li>测试无法给出一个可靠的结果</li>
<li>测试的顺序会影响到结果</li>
<li>不能并行进行测试</li>
</ul></li>
<li>很难确定设置状态的位置</li>
</ul>

<p>总之，从测试的角度来看，全局状态是很可怕的东西。</p>

<h3 id="toc_4">全局状态和全局变量的区别</h3>

<ul>
<li>全局状态不仅包括了全局变量，还包括系统的环境变量，以及人为的命令等。</li>
<li>全局变量是在程序生命周期中全局可访问的变量，常用来表示全局状态。</li>
</ul>

<h2 id="toc_5">单例模式</h2>

<p>有些程序员讨厌全局状态，却喜欢单例模式。但是，从某种意义上说，单例模式是另一种全局状态。当然我不是一棍子打死单例模式，应该说，写得不好的单例模式起到的作用就如同全局状态，让程序难以维护和测试。下面我们来讨论什么是好的单例模式，什么是坏的单例模式</p>

<h3 id="toc_6">坏的单例模式</h3>

<p>下面是典型的单例模式实现。</p>

<pre><code class="language-text">class AppSetting {
    private static AppSetting instance = new AppSetting();
    private Object state1;
    private Object state2;
    private Object state3;
    private AppSetting() {...}

    public static AppSetting getInstance() {
        return instance;
    }
}
</code></pre>

<p>我们先来思考一个问题：这个类包括了多少个全局变量？你可能觉得只有一个 <code>instance</code>，事实上一共有4个。只要 <code>instance</code> 一直存在，它的成员变量也会一直存在。也就是说一共有四个全局变量：<code>state1, state2, state3, instance</code>。</p>

<pre><code class="language-text">class App {
    int method() {
        return AppSetting.getInstance().doX();
    }
}

void testApp {
    ???
}
</code></pre>

<p>想想我们怎么测试上面的代码。单例模式下，你没有缝隙进入到 <code>method()</code> 函数中测试。</p>

<p>上面的单例模式存在一个很大的测试问题：测试无法覆盖所有的状态。因为状态是私有，同时它单例的。如果我们要测试三个状态怎么办，一个解决办法是在测试的时候把状态改为公有的。这看起来有点诡异，我们一方面又想用单例封装状态，一方面却在测试的时候要去修改代码让它的状态公有。可以说，这种单例模式给测试带来了极大的麻烦。</p>

<h3 id="toc_7">好的单例模式</h3>

<p>那么，什么是好的单例模式呢？看下面的代码。</p>

<pre><code class="language-text">class AppSetting {
    private Object state1;
    private Object state2;
    private Object state3;
    public AppSetting() {...}
}
</code></pre>

<p>第一眼看到这个代码，你可能觉得这哪里是单例模式，明明就是个普通的类。</p>

<p>是的，它的确是个普通的类。在这里我们让它不再着重于类自身的单例。什么意思？想想单例模式的本质是什么，单例模式主要是类保证在程序的生命周期内只有一个实例，其它对象访问到的是同一个实例。我们来看看，这种模式对测试带来了怎样的便利。</p>

<pre><code class="language-text">class App {
    AppSetting settings;
    App(AppSetting settings) {
        this.settings = settings;
    }

    int method() {
        return settings.doX();
    }
}

void testApp() {
     new App(new AppSetting(...)).method();
}
</code></pre>

<p>每个测试我们可以提供一个不同的 <code>AppSetting</code> 来进行测试，相比上面的单例模式，测试得到了更多的控制。我们可以通过不同的 <code>AppSetting</code> 的构造函数，改变程序的状态来进行测试。</p>

<p>看到这里，你可能有一个疑问：这样子写的代码根本就不是单例模式。的确，从类的实现上，<code>AppSetting</code> 的确不是单例模式的。这里我们强调的是逻辑上的单例，而不是代码实现上的单例。怎么理解？</p>

<p>首先，单例模式的传统实现是由类来管理这个唯一的实例，也就是我们上面说的“坏的单例模式”，而“好的单例模式”则是由程序来控制类的唯一实例，例如说，Spring IoC 容器中的 Bean，在容器的生命周期中，Bean 默认是单例的。（详细的解释可以看这篇文章 <a href="http://blog.xiaohansong.com/2015/10/21/IoC-and-DI/">控制反转（IoC）与依赖注入（DI）</a>）简单说，就是把单例类管理唯一实例的功能转移给外部容器，当你使用了 IoC 框架之后，你会发现，单例模式的实例完全可以通过容器管理，而不用我们写“坏的单例模式”。</p>

<h2 id="toc_8">设计好的 API</h2>

<p>全局状态同样会影响到 API 的好坏。</p>

<h3 id="toc_9">坏的 API</h3>

<p>我们来看一个坏的 API。</p>

<pre><code class="language-text">testCharge() {
    Database.connect();
    OfflineQueue.start();
    CreditCardProcessor.init();
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre>

<p>如果你对单例模式的坏处还没完全理解，或者你也喜欢写这样的代码，那么刷新编程观的时候到了。</p>

<p>上面是一个信用卡测试消费的例子。在实例化 <code>CreditCard</code> 之前要有三个初始化操作（明显都是单例模式）。现在问题来了：如果你是新来的测试人员，让你去测试 <code>CreditCard</code>，你看了 API 文档之后，兴冲冲地写下一些代码。</p>

<pre><code class="language-text">testCharge() {
    CreditCard cc = new CreditCard(&quot;123&quot;);
    cc.charge(100);
}
</code></pre>

<p>现在满怀期待的运行，结果却是熟悉的 <code>NullPointerException</code>。为什么？新来的你当然不知道创建 <code>CreditCard</code> 之前要先连接数据库，启动离线队列，初始化信用卡处理器。所以你只能去问开发人员。现在你知道问题出在哪了吗？</p>

<p>坏的单例模式让测试人员很难测试代码，因为你看了 API 之后只知道要实例化 <code>CreditCard</code>，然后调用 <code>charge</code>，完全不知道 <code>Database</code> 之类的全局状态是什么鬼。不要以为这只会为难到测试人员，六个月之后你就能体验到测试人员的痛苦。因此，全局状态让 API 有了误导性，让你以为做了正确的操作。</p>

<p>当然，文档写的清楚可以解决这个问题，然而好的文档可遇不可求，所以我们要有更好的解决办法。</p>

<h3 id="toc_10">好的 API</h3>

<p>设计好的 API，可以从代码层面上解决上面的问题，所谓代码就是最好的注释。</p>

<pre><code class="language-text">testCharge() {
    db = new Database(...);
    queue = new OfflineQueue(db);
    ccProc = new CreditCardProcessor(queue);
    CreditCard cc = new CreditCard(&quot;123&quot;, ccProc);
    cc.charge(100);
}
</code></pre>

<p>上面的代码通过<strong>让依赖参数化</strong>完美地解决上面的问题。现在，我们还是那个新来的测试人员，我们开始写测试代码。API 告诉我们，实例化 <code>CreditCard</code> 需要 <code>CreditCardProcessor</code> 作为参数，<code>CreditCardProcessor</code>需要 <code>OfflineQueue</code>，<code>OfflineQueue</code> 需要 <code>Database</code>。于是我们可以很清楚的写下上面的测试代码，不需要文档的辅助，我们也知道如何正确的使用 <code>CreditCard</code>。这就是好的 API 设计。</p>

<p>如果我们要让上面的配置类单例化，只需要使用 IoC 容器进行管理即可，通过依赖注入的方式，可以使代码更加清晰，易测试。</p>

<h2 id="toc_11">总结</h2>

<ul>
<li>全局状态是大多数测试问题的根源。</li>
<li>全局状态无法被测试控制，无法控制意味着无法进行彻底的测试。</li>
<li>单例模式是封装了全局状态的常用形式。这也是我们不提倡使用单例模式的原因，推荐用容器管理的单例模式。</li>
<li>全局状态会让 API 具有误导性。</li>
</ul>

<p><em>参考资料</em><br/>
<a href="https://www.youtube.com/watch?v=-FRm3VPhseI&amp;index=4&amp;list=PL693EFD059797C21E">全局状态与单例模式</a></p>

			</div>

		
	  
		<footer>
		 <p class="meta">

			<strong>Categories:</strong>&nbsp; 
			<span class="categories">
			
			    <a class='category' href='%E7%BC%96%E7%A8%8B.html'>编程</a>&nbsp;
			 
			</span>
		    </p>
		    <p class="meta">
		      
		 </p>
	    
		<div class="sharing">
		  
          
            <div id="disqus_thread"></div>
          

          

		</div>

	    <p class="meta">
	    
	        <a class="basic-alignment left" href="abstract-class-and-interface.html" 
	        title="Previous Post: 对抽象类与接口的一点思考">&laquo; 对抽象类与接口的一点思考</a>
	    
	    
	        <a class="basic-alignment right" href="clean-code-polymorphism.html" 
	        title="Next Post: 简洁代码之道（1）：用多态替代条件语句">简洁代码之道（1）：用多态替代条件语句 &raquo;</a>
	    
	    </p>
	  </footer>
	</article>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E7%BC%96%E7%A8%8B.html"><strong>编程&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="Java.html"><strong>Java&nbsp;(10)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E9%9A%8F%E7%AC%94.html"><strong>随笔&nbsp;(2)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%85%B6%E4%BB%96.html"><strong>其他&nbsp;(7)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%B7%A5%E5%85%B7.html"><strong>工具&nbsp;(5)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html"><strong>分布式系统&nbsp;(9)</strong></a>
	        
	        
	        
	      </li>
	  
	      <li class="post">
	        <a href="%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html"><strong>计算机基础&nbsp;(3)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="classloader-isolation.html">Java 类隔离加载的正确姿势</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="java-log-confict-solve.html">Java 日志框架冲突问题排查与总结</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="blockchain.html">多视角看区块链</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="cap-theorem.html">分布式系统：CAP 理论的前世今生</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="Continuous-Consistency.html">分布式系统：持续一致性</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  













<script src="asset/prism.js"></script>


<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

<script type="text/javascript">
    var disqus_shortname = 'hansong'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>

<script type="text/javascript">
var disqus_shortname = 'hansong'; 

(function () {
var s = document.createElement('script'); s.async = true;
s.type = 'text/javascript';
s.src = '//' + disqus_shortname + '.disqus.com/count.js';
(document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>
  
    


</body>
</html>